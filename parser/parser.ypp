%parse-param {stardec::parsed_item &item} {bool v}

%code requires {
    #include <vector>
    #include "parser/parser_struct.hpp"
}
%{
  #include <string>
  #include <memory>
  #include <iostream>
  #include <algorithm>
  #include <stdexcept>
  #include "parser/parser_struct.hpp"

  int yyparse(stardec::parsed_item&, bool);
  int yylex(void);

  void yyerror (stardec::parsed_item &i, bool v, char const *s) {
     fprintf (stderr, "%s\n", s);
     exit(-1);
   }
%}

%token ARG ATT GOAL LEFTPAR RIGHTPAR DOT COMMA AND OR NOT COND FROZEN INITIAL WORDS
%union {
    char *str;
    std::vector<char *> *arglabels;
}
%token <str> LABEL
%type <arglabels> labellist

%start line
%%

line : argument
        | attack
        | goal
        | words

argument: ARG LEFTPAR LABEL RIGHTPAR DOT {
    item.type = stardec::parsed_type::ARG;
    item.arg = std::make_unique<stardec::parsed_argument>($3);
    if(v)
        std::cout << "Argument parsed: " << $3 << std::endl;
    free($3);
}

words: WORDS LEFTPAR LABEL COMMA labellist RIGHTPAR DOT {
    std::vector<std::string> w($5->cbegin(), $5->cend());
    item.type = stardec::parsed_type::WORDS;
    item.words = std::make_unique<stardec::parsed_words>($3, w);

    free($3);
    for(auto s : *$5) free(s);
    delete $5;
}

attack: ATT LEFTPAR LABEL COMMA LABEL RIGHTPAR DOT {
    item.type = stardec::parsed_type::ATK;
    item.atk = std::make_unique<stardec::parsed_attack>($3, $5);
    free($3); free($5);
}

goal: GOAL LEFTPAR LABEL RIGHTPAR DOT {
    item.type = stardec::parsed_type::GOAL;
    item.goal = std::make_unique<stardec::parsed_goal>($3);
    if(v)
        std::cout << "Goal parsed: " << $3 << std::endl << std::endl;
    free($3);
}

labellist: labellist COMMA LABEL {$1->push_back($3); $$ = $1;}
          | LABEL {auto v = new std::vector<char*>(); v->push_back($1); $$ = v;}
